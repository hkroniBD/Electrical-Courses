# 🎯 Model Predictive Control (MPC): From Fundamentals to Advanced Applications

## Table of Contents
1. [Introduction to MPC](#introduction)
2. [Mathematical Foundation](#mathematical-foundation)
3. [MPC Algorithm](#mpc-algorithm)
4. [Implementation Examples](#implementation-examples)
5. [Advanced Topics](#advanced-topics)
6. [Controller Comparison](#controller-comparison)
7. [When to Use MPC](#when-to-use-mpc)
8. [Real-World Applications](#real-world-applications)
9. [Advantages and Disadvantages](#advantages-and-disadvantages)

---

## 1. Introduction to MPC {#introduction}

### 🌟 What is Model Predictive Control?

Model Predictive Control (MPC) is an advanced control strategy that uses a mathematical model of the system to predict future behavior and optimize control actions over a finite time horizon. It's like a chess player who thinks several moves ahead before making a decision.

### 🏗️ Core Components

| Component | Description | Purpose |
|-----------|-------------|---------|
| **🎯 Prediction Model** | Mathematical representation of system dynamics | Predict future system behavior |
| **📊 Cost Function** | Objective function to be minimized | Define control objectives |
| **⛓️ Constraints** | Physical and operational limits | Ensure safe operation |
| **⏱️ Horizons** | Prediction and control time windows | Define optimization scope |

### 🔄 Key Principles

- **🔮 Predictive Nature**: Uses system models to predict future states
- **⚖️ Constraint Handling**: Naturally incorporates constraints
- **🎯 Optimization-Based**: Solves optimization problem at each step
- **🔄 Receding Horizon**: Continuously updates predictions

---

## 2. Mathematical Foundation {#mathematical-foundation}

### 📐 System Model

For linear systems, MPC typically uses state-space representation:

```
State Equation:  x(k+1) = A·x(k) + B·u(k)
Output Equation: y(k) = C·x(k) + D·u(k)

Where:
- x(k): state vector at time k
- u(k): input vector at time k
- y(k): output vector at time k
- A, B, C, D: system matrices
```

### 🎯 Cost Function

The typical MPC cost function includes tracking error and control effort:

```
J = Σ[i=1 to Np] ||y(k+i|k) - r(k+i)||²Q + Σ[i=0 to Nc-1] ||u(k+i|k)||²R

Where:
- Np: prediction horizon
- Nc: control horizon
- Q: output weighting matrix
- R: input weighting matrix
- r(k+i): reference signal
- ||·||²: weighted squared norm
```

### ⛓️ Constraints

MPC handles various constraint types:

| Constraint Type | Mathematical Form | Example |
|----------------|-------------------|---------|
| **Input Constraints** | `u_min ≤ u(k+i) ≤ u_max` | Actuator limits |
| **Input Rate Constraints** | `Δu_min ≤ Δu(k+i) ≤ Δu_max` | Slew rate limits |
| **Output Constraints** | `y_min ≤ y(k+i) ≤ y_max` | Safety limits |
| **State Constraints** | `x_min ≤ x(k+i) ≤ x_max` | Physical boundaries |

### 🔍 Optimization Problem

At each time step, MPC solves:

```
minimize:   J(x(k), U)
subject to: x(k+i+1|k) = A·x(k+i|k) + B·u(k+i|k)
            y(k+i|k) = C·x(k+i|k)
            Constraint equations
            
Where U = [u(k|k), u(k+1|k), ..., u(k+Nc-1|k)]
```

---

## 3. MPC Algorithm {#mpc-algorithm}

### 🔄 Step-by-Step Process

1. **📏 Measure Current State**: Obtain x(k) through sensors or estimation
2. **🔮 Predict Future States**: Use model to predict behavior over Np steps
3. **⚡ Solve Optimization**: Minimize cost function subject to constraints
4. **🎯 Apply Control**: Implement only first control action u(k)
5. **➡️ Shift Horizon**: Move to next time step and repeat

### ⏱️ Timing Considerations

| Parameter | Typical Range | Impact |
|-----------|---------------|--------|
| **Prediction Horizon (Np)** | 10-50 steps | Stability, performance |
| **Control Horizon (Nc)** | 2-10 steps | Computational load |
| **Sample Time (Ts)** | System dependent | Response speed |

---

## 4. Implementation Examples {#implementation-examples}

### 🐍 Python Implementation

```python
import numpy as np
import cvxpy as cp
from scipy.linalg import expm
import matplotlib.pyplot as plt

class LinearMPC:
    def __init__(self, A, B, C, Q, R, N_pred=10, N_ctrl=3):
        """
        Linear MPC Controller
        
        Parameters:
        - A, B, C: System matrices
        - Q, R: Weighting matrices  
        - N_pred: Prediction horizon
        - N_ctrl: Control horizon
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        self.N_pred = N_pred
        self.N_ctrl = N_ctrl
        
        self.nx = A.shape[0]  # States
        self.nu = B.shape[1]  # Inputs
        self.ny = C.shape[0]  # Outputs
        
    def solve(self, x0, r_seq, u_min=None, u_max=None):
        """Solve MPC optimization problem"""
        # Decision variables
        u = cp.Variable((self.N_ctrl, self.nu))
        
        # Initialize
        x = x0
        cost = 0
        constraints = []
        
        # Prediction loop
        for i in range(self.N_pred):
            # Control input
            if i < self.N_ctrl:
                u_current = u[i]
            else:
                u_current = u[-1]  # Hold last input
                
            # State prediction
            x = self.A @ x + self.B @ u_current
            y = self.C @ x
            
            # Cost function
            if i < len(r_seq):
                cost += cp.quad_form(y - r_seq[i], self.Q)
                
            if i < self.N_ctrl:
                cost += cp.quad_form(u_current, self.R)
                
        # Constraints
        if u_min is not None:
            constraints.append(u >= u_min)
        if u_max is not None:
            constraints.append(u <= u_max)
            
        # Solve
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve()
        
        if problem.status == cp.OPTIMAL:
            return u.value[0]
        else:
            return np.zeros(self.nu)

# Example: Mass-Spring-Damper System
def mass_spring_damper_example():
    """MPC for second-order system"""
    
    # System parameters
    m, k, c, dt = 1.0, 1.0, 0.5, 0.1
    
    # Continuous system
    Ac = np.array([[0, 1], [-k/m, -c/m]])
    Bc = np.array([[0], [1/m]])
    Cc = np.array([[1, 0]])
    
    # Discretize
    n = Ac.shape[0]
    M = np.block([[Ac, Bc], [np.zeros((1, n+1))]])
    M_exp = expm(M * dt)
    A, B = M_exp[:n, :n], M_exp[:n, n:]
    C = Cc
    
    # MPC setup
    Q = np.array([[10.0]])   # Output weight
    R = np.array([[0.1]])    # Input weight
    mpc = LinearMPC(A, B, C, Q, R, N_pred=15, N_ctrl=5)
    
    # Simulation
    T_sim = 100
    x = np.array([1.0, 0.0])  # Initial condition
    
    # Reference trajectory
    reference = np.zeros(T_sim)
    reference[20:] = 1.0  # Step at t=20
    
    # Storage
    states, outputs, inputs = [], [], []
    
    for k in range(T_sim):
        # Reference sequence
        r_seq = [np.array([reference[min(k+i, T_sim-1)]]) 
                for i in range(mpc.N_pred)]
        
        # Solve MPC
        u_opt = mpc.solve(x, r_seq, u_min=-3.0, u_max=3.0)
        
        # Apply control
        x = A @ x + B @ u_opt.reshape(-1)
        y = C @ x
        
        # Store
        states.append(x.copy())
        outputs.append(y[0])
        inputs.append(u_opt[0])
    
    return np.array(states), outputs, inputs, reference

# Run simulation
states, outputs, inputs, ref = mass_spring_damper_example()

# Plotting code would go here...
```

### 📊 MATLAB Implementation

```matlab
function mpc_matlab_example()
    %% System Definition
    % Mass-spring-damper system
    m = 1; k = 1; c = 0.5; dt = 0.1;
    
    % State-space matrices
    A = [1 dt; -k*dt/m 1-c*dt/m];
    B = [0; dt/m];
    C = [1 0];
    D = 0;
    
    % Create system
    sys = ss(A, B, C, D, dt);
    
    %% MPC Controller Design
    mpc_controller = mpc(sys);
    
    % Horizons
    mpc_controller.PredictionHorizon = 15;
    mpc_controller.ControlHorizon = 5;
    
    % Weights
    mpc_controller.Weights.OutputVariables = 10;
    mpc_controller.Weights.ManipulatedVariables = 0.1;
    mpc_controller.Weights.ManipulatedVariablesRate = 0.01;
    
    % Constraints
    mpc_controller.ManipulatedVariables.Min = -3;
    mpc_controller.ManipulatedVariables.Max = 3;
    mpc_controller.OutputVariables.Min = -2;
    mpc_controller.OutputVariables.Max = 2;
    
    %% Simulation
    T_sim = 100;
    reference = [zeros(20,1); ones(T_sim-20,1)];
    
    % Closed-loop simulation
    sim(mpc_controller, T_sim, reference);
    
    %% Plot results
    figure;
    subplot(3,1,1); plot(1:T_sim, reference, 'r--', 'LineWidth', 2);
    hold on; % Add output plot
    title('MPC Control Performance');
    ylabel('Output'); legend('Reference', 'Output');
    
    subplot(3,1,2); % Add control input plot
    ylabel('Control Input');
    
    subplot(3,1,3); % Add states plot
    ylabel('States'); xlabel('Time');
end
```

---

## 5. Advanced Topics {#advanced-topics}

### 🚀 Nonlinear MPC (NMPC)

For nonlinear systems, the prediction model becomes:

```
x(k+1) = f(x(k), u(k))
y(k) = h(x(k), u(k))
```

**Implementation Challenges:**
- **🔄 Nonlinear optimization**: Requires iterative solvers
- **⏱️ Real-time constraints**: Higher computational burden
- **🎯 Local minima**: Multiple solutions possible

### 🎛️ Robust MPC

Handles model uncertainty and disturbances:

| Approach | Description | Pros | Cons |
|----------|-------------|------|------|
| **Tube MPC** | Maintains system in invariant tube | Recursive feasibility | Conservative |
| **Stochastic MPC** | Probabilistic constraints | Less conservative | Complex implementation |
| **Min-Max MPC** | Worst-case optimization | Guaranteed performance | Very conservative |

### 📊 Economic MPC

Optimizes economic performance directly:

```
J_economic = Σ[i=0 to Np-1] L_e(x(k+i), u(k+i))

Where L_e is economic stage cost (e.g., energy consumption, profit)
```

### 🏃 Fast MPC Methods

| Method | Approach | Speed Gain | Applications |
|--------|----------|------------|--------------|
| **Explicit MPC** | Pre-compute control law | 100-1000x | Simple systems |
| **Multi-parametric QP** | Parametric optimization | 10-100x | Linear systems |
| **Real-time Iteration** | Warm-start optimization | 5-20x | Nonlinear systems |

---

## 6. Controller Comparison {#controller-comparison}

### 📊 Comprehensive Comparison Table

| Control Method | **Multivariable** | **Constraints** | **Optimality** | **Disturbance Rejection** | **Implementation** | **Computational Load** |
|----------------|-------------------|-----------------|----------------|---------------------------|-------------------|----------------------|
| **🎯 MPC** | ✅ Excellent | ✅ Native | ✅ Optimal | ⚠️ Good | ⚠️ Complex | 🔴 High |
| **📐 PID** | ❌ Poor | ❌ None | ❌ Heuristic | ✅ Good | ✅ Simple | ✅ Very Low |
| **🎛️ LQR** | ✅ Excellent | ❌ None | ✅ Optimal | ⚠️ Moderate | ⚠️ Moderate | ⚠️ Medium |
| **🔄 H∞** | ✅ Good | ❌ Limited | ⚠️ Robust Optimal | ✅ Excellent | 🔴 Complex | ⚠️ Medium |
| **🎯 LQG** | ✅ Good | ❌ None | ✅ Stochastic Optimal | ✅ Good | ⚠️ Moderate | ⚠️ Medium |
| **🔀 Sliding Mode** | ⚠️ Moderate | ⚠️ Some | ❌ Heuristic | ✅ Excellent | ⚠️ Moderate | ⚠️ Medium |

### 🏆 Performance Metrics Comparison

| Metric | MPC | PID | LQR | H∞ | LQG |
|--------|-----|-----|-----|----|----|
| **🎯 Tracking Performance** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **⛓️ Constraint Handling** | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ | ⭐⭐ | ⭐ |
| **🔧 Tuning Difficulty** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **💻 Implementation Cost** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **🎪 Flexibility** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |

---

## 7. When to Use MPC {#when-to-use-mpc}

### ✅ Use MPC When:

| Scenario | Reason | Example |
|----------|---------|---------|
| **🎛️ Multiple inputs/outputs** | Natural MIMO handling | Chemical processes |
| **⛓️ Hard constraints exist** | Safety-critical limits | Automotive control |
| **🎯 Optimal performance needed** | Economic optimization | Power generation |
| **🔮 Preview information available** | Future disturbances known | Wind turbine control |
| **⚖️ Trade-offs required** | Multiple objectives | Building HVAC |
| **🏭 Process has delays** | Predictive compensation | Steel rolling mills |

### ❌ Avoid MPC When:

| Scenario | Alternative | Reason |
|----------|-------------|---------|
| **⚡ Fast dynamics (< 1ms)** | PID, LQR | Computational delay |
| **💰 Cost-sensitive applications** | PID | Implementation complexity |
| **🔧 Simple SISO systems** | PID | Overkill |
| **📱 Limited computing power** | Classical control | Resource constraints |
| **🛠️ Maintenance concerns** | Robust control | Reliability needs |

### 🎯 MPC Sweet Spot

**Ideal for systems with:**
- **Sample times**: 100ms - 10s
- **Prediction horizons**: 10-50 steps  
- **States**: 2-20
- **Inputs**: 1-10
- **Constraints**: Present and important

---

## 8. Real-World Applications {#real-world-applications}

### 🏭 Industrial Process Control

| Industry | Application | Benefits | Challenges |
|----------|-------------|----------|------------|
| **🧪 Chemical** | Distillation columns | Multi-loop coordination | Nonlinear dynamics |
| **⚡ Power** | Gas turbine control | Efficiency optimization | Fast disturbances |
| **🏗️ Cement** | Kiln temperature control | Energy savings | Model uncertainty |
| **📄 Paper** | Basis weight control | Quality improvement | Cross-coupling |

### 🚗 Automotive Applications

**🛣️ Adaptive Cruise Control (ACC)**
```python
# Simplified ACC MPC formulation
def acc_mpc_design():
    # States: [position, velocity, acceleration]
    # Inputs: [throttle, brake]
    # Constraints: speed limits, following distance
    # Objective: comfort + fuel economy + safety
    pass
```

**🏁 Path Planning and Tracking**
- **Inputs**: Steering angle, acceleration
- **Constraints**: Vehicle dynamics, road boundaries
- **Objective**: Minimize tracking error and control effort

### 🌊 Renewable Energy

**💨 Wind Turbine Control**
- **Pitch angle control** for power regulation
- **Yaw control** for wind tracking
- **Load mitigation** through predictive control

**☀️ Solar Power Systems**
- **Maximum power point tracking**
- **Grid integration** and stability
- **Energy storage** coordination

### 🏢 Building Automation

**🌡️ HVAC Systems**
```
Objectives:
- Minimize energy consumption
- Maintain comfort (temperature, humidity)
- Handle occupancy predictions
- Consider weather forecasts

Constraints:
- Equipment capacity limits
- Indoor air quality requirements
- Demand response signals
```

### 🚀 Aerospace Applications

| System | Control Variables | Constraints | Challenges |
|--------|------------------|-------------|------------|
| **🛩️ Flight Control** | Control surfaces | Flight envelope | Nonlinear dynamics |
| **🚀 Spacecraft** | Thrusters | Fuel limits | Orbital mechanics |
| **🚁 UAV** | Rotor speeds | Battery life | Disturbance rejection |

---

## 9. Advantages and Disadvantages {#advantages-and-disadvantages}

### ✅ Advantages of MPC

| Advantage | Description | Impact |
|-----------|-------------|---------|
| **🎯 Optimal Control** | Minimizes cost function at each step | Better performance |
| **⛓️ Constraint Handling** | Naturally incorporates limits | Safety assurance |
| **🔮 Predictive Nature** | Uses future information | Proactive control |
| **🎛️ MIMO Capability** | Handles multiple variables naturally | System-wide optimization |
| **🔧 Flexibility** | Easy to modify objectives/constraints | Adaptable to changes |
| **📊 Systematic Design** | Model-based approach | Principled tuning |

### ❌ Disadvantages of MPC

| Disadvantage | Description | Mitigation |
|--------------|-------------|------------|
| **💻 Computational Burden** | Requires solving optimization online | Faster algorithms, better hardware |
| **🎯 Model Dependency** | Performance depends on model quality | Robust/adaptive MPC |
| **🔧 Complex Implementation** | Requires expertise to implement | Commercial tools, education |
| **💰 High Cost** | Expensive hardware/software | Cost-benefit analysis |
| **🛠️ Maintenance** | Requires skilled personnel | Training, documentation |
| **📏 Parameter Tuning** | Many parameters to adjust | Systematic tuning methods |

### ⚖️ Trade-offs Summary

| Aspect | Benefit | Cost |
|--------|---------|------|
| **Performance** | Optimal control | High computation |
| **Safety** | Constraint handling | Complex implementation |
| **Flexibility** | Easy modifications | Expert knowledge needed |
| **Predictive** | Future optimization | Model uncertainty |

---

## 🎓 Summary and Key Takeaways

### 🎯 When MPC Excels
- **Complex multivariable systems** with constraints
- **Applications requiring optimization** (economic, energy)
- **Systems with preview information** available
- **Safety-critical applications** with hard limits

### ⚠️ When to Consider Alternatives
- **Simple SISO systems** → Use PID
- **Very fast dynamics** → Use classical control
- **Limited computational resources** → Use simpler methods
- **High reliability requirements** → Use robust control

### 🚀 Future Trends
- **🤖 Machine Learning Integration**: Data-driven MPC
- **☁️ Cloud-based MPC**: Distributed optimization
- **⚡ Real-time Implementation**: Faster algorithms
- **🔧 Plug-and-play Solutions**: Easier deployment

### 📚 Learning Path
1. **Master fundamentals**: Linear algebra, optimization
2. **Understand system modeling**: State-space, identification
3. **Start with linear MPC**: Simple examples
4. **Progress to nonlinear MPC**: Advanced applications
5. **Explore specialized topics**: Robust, stochastic, economic MPC

---

*"MPC is not just a control technique; it's a framework for systematic thinking about optimal control under constraints."*
