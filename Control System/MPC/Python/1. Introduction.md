# ğŸ¯ Model Predictive Control (MPC): From Fundamentals to Advanced Applications

## Table of Contents
1. [Introduction to MPC](#introduction)
2. [Mathematical Foundation](#mathematical-foundation)
3. [MPC Algorithm](#mpc-algorithm)
4. [Implementation Examples](#implementation-examples)
5. [Advanced Topics](#advanced-topics)
6. [Controller Comparison](#controller-comparison)
7. [When to Use MPC](#when-to-use-mpc)
8. [Real-World Applications](#real-world-applications)
9. [Advantages and Disadvantages](#advantages-and-disadvantages)

---

## 1. Introduction to MPC {#introduction}

### ğŸŒŸ What is Model Predictive Control?

Model Predictive Control (MPC) is an advanced control strategy that uses a mathematical model of the system to predict future behavior and optimize control actions over a finite time horizon. It's like a chess player who thinks several moves ahead before making a decision.

### ğŸ—ï¸ Core Components

| Component | Description | Purpose |
|-----------|-------------|---------|
| **ğŸ¯ Prediction Model** | Mathematical representation of system dynamics | Predict future system behavior |
| **ğŸ“Š Cost Function** | Objective function to be minimized | Define control objectives |
| **â›“ï¸ Constraints** | Physical and operational limits | Ensure safe operation |
| **â±ï¸ Horizons** | Prediction and control time windows | Define optimization scope |

### ğŸ”„ Key Principles

- **ğŸ”® Predictive Nature**: Uses system models to predict future states
- **âš–ï¸ Constraint Handling**: Naturally incorporates constraints
- **ğŸ¯ Optimization-Based**: Solves optimization problem at each step
- **ğŸ”„ Receding Horizon**: Continuously updates predictions

---

## 2. Mathematical Foundation {#mathematical-foundation}

### ğŸ“ System Model

For linear systems, MPC typically uses state-space representation:

```
State Equation:  x(k+1) = AÂ·x(k) + BÂ·u(k)
Output Equation: y(k) = CÂ·x(k) + DÂ·u(k)

Where:
- x(k): state vector at time k
- u(k): input vector at time k
- y(k): output vector at time k
- A, B, C, D: system matrices
```

### ğŸ¯ Cost Function

The typical MPC cost function includes tracking error and control effort:

```
J = Î£[i=1 to Np] ||y(k+i|k) - r(k+i)||Â²Q + Î£[i=0 to Nc-1] ||u(k+i|k)||Â²R

Where:
- Np: prediction horizon
- Nc: control horizon
- Q: output weighting matrix
- R: input weighting matrix
- r(k+i): reference signal
- ||Â·||Â²: weighted squared norm
```

### â›“ï¸ Constraints

MPC handles various constraint types:

| Constraint Type | Mathematical Form | Example |
|----------------|-------------------|---------|
| **Input Constraints** | `u_min â‰¤ u(k+i) â‰¤ u_max` | Actuator limits |
| **Input Rate Constraints** | `Î”u_min â‰¤ Î”u(k+i) â‰¤ Î”u_max` | Slew rate limits |
| **Output Constraints** | `y_min â‰¤ y(k+i) â‰¤ y_max` | Safety limits |
| **State Constraints** | `x_min â‰¤ x(k+i) â‰¤ x_max` | Physical boundaries |

### ğŸ” Optimization Problem

At each time step, MPC solves:

```
minimize:   J(x(k), U)
subject to: x(k+i+1|k) = AÂ·x(k+i|k) + BÂ·u(k+i|k)
            y(k+i|k) = CÂ·x(k+i|k)
            Constraint equations
            
Where U = [u(k|k), u(k+1|k), ..., u(k+Nc-1|k)]
```

---

## 3. MPC Algorithm {#mpc-algorithm}

### ğŸ”„ Step-by-Step Process

1. **ğŸ“ Measure Current State**: Obtain x(k) through sensors or estimation
2. **ğŸ”® Predict Future States**: Use model to predict behavior over Np steps
3. **âš¡ Solve Optimization**: Minimize cost function subject to constraints
4. **ğŸ¯ Apply Control**: Implement only first control action u(k)
5. **â¡ï¸ Shift Horizon**: Move to next time step and repeat

### â±ï¸ Timing Considerations

| Parameter | Typical Range | Impact |
|-----------|---------------|--------|
| **Prediction Horizon (Np)** | 10-50 steps | Stability, performance |
| **Control Horizon (Nc)** | 2-10 steps | Computational load |
| **Sample Time (Ts)** | System dependent | Response speed |

---

## 4. Implementation Examples {#implementation-examples}

### ğŸ Python Implementation

```python
import numpy as np
import cvxpy as cp
from scipy.linalg import expm
import matplotlib.pyplot as plt

class LinearMPC:
    def __init__(self, A, B, C, Q, R, N_pred=10, N_ctrl=3):
        """
        Linear MPC Controller
        
        Parameters:
        - A, B, C: System matrices
        - Q, R: Weighting matrices  
        - N_pred: Prediction horizon
        - N_ctrl: Control horizon
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        self.N_pred = N_pred
        self.N_ctrl = N_ctrl
        
        self.nx = A.shape[0]  # States
        self.nu = B.shape[1]  # Inputs
        self.ny = C.shape[0]  # Outputs
        
    def solve(self, x0, r_seq, u_min=None, u_max=None):
        """Solve MPC optimization problem"""
        # Decision variables
        u = cp.Variable((self.N_ctrl, self.nu))
        
        # Initialize
        x = x0
        cost = 0
        constraints = []
        
        # Prediction loop
        for i in range(self.N_pred):
            # Control input
            if i < self.N_ctrl:
                u_current = u[i]
            else:
                u_current = u[-1]  # Hold last input
                
            # State prediction
            x = self.A @ x + self.B @ u_current
            y = self.C @ x
            
            # Cost function
            if i < len(r_seq):
                cost += cp.quad_form(y - r_seq[i], self.Q)
                
            if i < self.N_ctrl:
                cost += cp.quad_form(u_current, self.R)
                
        # Constraints
        if u_min is not None:
            constraints.append(u >= u_min)
        if u_max is not None:
            constraints.append(u <= u_max)
            
        # Solve
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve()
        
        if problem.status == cp.OPTIMAL:
            return u.value[0]
        else:
            return np.zeros(self.nu)

# Example: Mass-Spring-Damper System
def mass_spring_damper_example():
    """MPC for second-order system"""
    
    # System parameters
    m, k, c, dt = 1.0, 1.0, 0.5, 0.1
    
    # Continuous system
    Ac = np.array([[0, 1], [-k/m, -c/m]])
    Bc = np.array([[0], [1/m]])
    Cc = np.array([[1, 0]])
    
    # Discretize
    n = Ac.shape[0]
    M = np.block([[Ac, Bc], [np.zeros((1, n+1))]])
    M_exp = expm(M * dt)
    A, B = M_exp[:n, :n], M_exp[:n, n:]
    C = Cc
    
    # MPC setup
    Q = np.array([[10.0]])   # Output weight
    R = np.array([[0.1]])    # Input weight
    mpc = LinearMPC(A, B, C, Q, R, N_pred=15, N_ctrl=5)
    
    # Simulation
    T_sim = 100
    x = np.array([1.0, 0.0])  # Initial condition
    
    # Reference trajectory
    reference = np.zeros(T_sim)
    reference[20:] = 1.0  # Step at t=20
    
    # Storage
    states, outputs, inputs = [], [], []
    
    for k in range(T_sim):
        # Reference sequence
        r_seq = [np.array([reference[min(k+i, T_sim-1)]]) 
                for i in range(mpc.N_pred)]
        
        # Solve MPC
        u_opt = mpc.solve(x, r_seq, u_min=-3.0, u_max=3.0)
        
        # Apply control
        x = A @ x + B @ u_opt.reshape(-1)
        y = C @ x
        
        # Store
        states.append(x.copy())
        outputs.append(y[0])
        inputs.append(u_opt[0])
    
    return np.array(states), outputs, inputs, reference

# Run simulation
states, outputs, inputs, ref = mass_spring_damper_example()

# Plotting code would go here...
```

### ğŸ“Š MATLAB Implementation

```matlab
function mpc_matlab_example()
    %% System Definition
    % Mass-spring-damper system
    m = 1; k = 1; c = 0.5; dt = 0.1;
    
    % State-space matrices
    A = [1 dt; -k*dt/m 1-c*dt/m];
    B = [0; dt/m];
    C = [1 0];
    D = 0;
    
    % Create system
    sys = ss(A, B, C, D, dt);
    
    %% MPC Controller Design
    mpc_controller = mpc(sys);
    
    % Horizons
    mpc_controller.PredictionHorizon = 15;
    mpc_controller.ControlHorizon = 5;
    
    % Weights
    mpc_controller.Weights.OutputVariables = 10;
    mpc_controller.Weights.ManipulatedVariables = 0.1;
    mpc_controller.Weights.ManipulatedVariablesRate = 0.01;
    
    % Constraints
    mpc_controller.ManipulatedVariables.Min = -3;
    mpc_controller.ManipulatedVariables.Max = 3;
    mpc_controller.OutputVariables.Min = -2;
    mpc_controller.OutputVariables.Max = 2;
    
    %% Simulation
    T_sim = 100;
    reference = [zeros(20,1); ones(T_sim-20,1)];
    
    % Closed-loop simulation
    sim(mpc_controller, T_sim, reference);
    
    %% Plot results
    figure;
    subplot(3,1,1); plot(1:T_sim, reference, 'r--', 'LineWidth', 2);
    hold on; % Add output plot
    title('MPC Control Performance');
    ylabel('Output'); legend('Reference', 'Output');
    
    subplot(3,1,2); % Add control input plot
    ylabel('Control Input');
    
    subplot(3,1,3); % Add states plot
    ylabel('States'); xlabel('Time');
end
```

---

## 5. Advanced Topics {#advanced-topics}

### ğŸš€ Nonlinear MPC (NMPC)

For nonlinear systems, the prediction model becomes:

```
x(k+1) = f(x(k), u(k))
y(k) = h(x(k), u(k))
```

**Implementation Challenges:**
- **ğŸ”„ Nonlinear optimization**: Requires iterative solvers
- **â±ï¸ Real-time constraints**: Higher computational burden
- **ğŸ¯ Local minima**: Multiple solutions possible

### ğŸ›ï¸ Robust MPC

Handles model uncertainty and disturbances:

| Approach | Description | Pros | Cons |
|----------|-------------|------|------|
| **Tube MPC** | Maintains system in invariant tube | Recursive feasibility | Conservative |
| **Stochastic MPC** | Probabilistic constraints | Less conservative | Complex implementation |
| **Min-Max MPC** | Worst-case optimization | Guaranteed performance | Very conservative |

### ğŸ“Š Economic MPC

Optimizes economic performance directly:

```
J_economic = Î£[i=0 to Np-1] L_e(x(k+i), u(k+i))

Where L_e is economic stage cost (e.g., energy consumption, profit)
```

### ğŸƒ Fast MPC Methods

| Method | Approach | Speed Gain | Applications |
|--------|----------|------------|--------------|
| **Explicit MPC** | Pre-compute control law | 100-1000x | Simple systems |
| **Multi-parametric QP** | Parametric optimization | 10-100x | Linear systems |
| **Real-time Iteration** | Warm-start optimization | 5-20x | Nonlinear systems |

---

## 6. Controller Comparison {#controller-comparison}

### ğŸ“Š Comprehensive Comparison Table

| Control Method | **Multivariable** | **Constraints** | **Optimality** | **Disturbance Rejection** | **Implementation** | **Computational Load** |
|----------------|-------------------|-----------------|----------------|---------------------------|-------------------|----------------------|
| **ğŸ¯ MPC** | âœ… Excellent | âœ… Native | âœ… Optimal | âš ï¸ Good | âš ï¸ Complex | ğŸ”´ High |
| **ğŸ“ PID** | âŒ Poor | âŒ None | âŒ Heuristic | âœ… Good | âœ… Simple | âœ… Very Low |
| **ğŸ›ï¸ LQR** | âœ… Excellent | âŒ None | âœ… Optimal | âš ï¸ Moderate | âš ï¸ Moderate | âš ï¸ Medium |
| **ğŸ”„ Hâˆ** | âœ… Good | âŒ Limited | âš ï¸ Robust Optimal | âœ… Excellent | ğŸ”´ Complex | âš ï¸ Medium |
| **ğŸ¯ LQG** | âœ… Good | âŒ None | âœ… Stochastic Optimal | âœ… Good | âš ï¸ Moderate | âš ï¸ Medium |
| **ğŸ”€ Sliding Mode** | âš ï¸ Moderate | âš ï¸ Some | âŒ Heuristic | âœ… Excellent | âš ï¸ Moderate | âš ï¸ Medium |

### ğŸ† Performance Metrics Comparison

| Metric | MPC | PID | LQR | Hâˆ | LQG |
|--------|-----|-----|-----|----|----|
| **ğŸ¯ Tracking Performance** | â­â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­ |
| **â›“ï¸ Constraint Handling** | â­â­â­â­â­ | â­ | â­ | â­â­ | â­ |
| **ğŸ”§ Tuning Difficulty** | â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­ | â­â­â­ |
| **ğŸ’» Implementation Cost** | â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­ | â­â­â­ |
| **ğŸª Flexibility** | â­â­â­â­â­ | â­â­ | â­â­â­ | â­â­â­ | â­â­â­ |

---

## 7. When to Use MPC {#when-to-use-mpc}

### âœ… Use MPC When:

| Scenario | Reason | Example |
|----------|---------|---------|
| **ğŸ›ï¸ Multiple inputs/outputs** | Natural MIMO handling | Chemical processes |
| **â›“ï¸ Hard constraints exist** | Safety-critical limits | Automotive control |
| **ğŸ¯ Optimal performance needed** | Economic optimization | Power generation |
| **ğŸ”® Preview information available** | Future disturbances known | Wind turbine control |
| **âš–ï¸ Trade-offs required** | Multiple objectives | Building HVAC |
| **ğŸ­ Process has delays** | Predictive compensation | Steel rolling mills |

### âŒ Avoid MPC When:

| Scenario | Alternative | Reason |
|----------|-------------|---------|
| **âš¡ Fast dynamics (< 1ms)** | PID, LQR | Computational delay |
| **ğŸ’° Cost-sensitive applications** | PID | Implementation complexity |
| **ğŸ”§ Simple SISO systems** | PID | Overkill |
| **ğŸ“± Limited computing power** | Classical control | Resource constraints |
| **ğŸ› ï¸ Maintenance concerns** | Robust control | Reliability needs |

### ğŸ¯ MPC Sweet Spot

**Ideal for systems with:**
- **Sample times**: 100ms - 10s
- **Prediction horizons**: 10-50 steps  
- **States**: 2-20
- **Inputs**: 1-10
- **Constraints**: Present and important

---

## 8. Real-World Applications {#real-world-applications}

### ğŸ­ Industrial Process Control

| Industry | Application | Benefits | Challenges |
|----------|-------------|----------|------------|
| **ğŸ§ª Chemical** | Distillation columns | Multi-loop coordination | Nonlinear dynamics |
| **âš¡ Power** | Gas turbine control | Efficiency optimization | Fast disturbances |
| **ğŸ—ï¸ Cement** | Kiln temperature control | Energy savings | Model uncertainty |
| **ğŸ“„ Paper** | Basis weight control | Quality improvement | Cross-coupling |

### ğŸš— Automotive Applications

**ğŸ›£ï¸ Adaptive Cruise Control (ACC)**
```python
# Simplified ACC MPC formulation
def acc_mpc_design():
    # States: [position, velocity, acceleration]
    # Inputs: [throttle, brake]
    # Constraints: speed limits, following distance
    # Objective: comfort + fuel economy + safety
    pass
```

**ğŸ Path Planning and Tracking**
- **Inputs**: Steering angle, acceleration
- **Constraints**: Vehicle dynamics, road boundaries
- **Objective**: Minimize tracking error and control effort

### ğŸŒŠ Renewable Energy

**ğŸ’¨ Wind Turbine Control**
- **Pitch angle control** for power regulation
- **Yaw control** for wind tracking
- **Load mitigation** through predictive control

**â˜€ï¸ Solar Power Systems**
- **Maximum power point tracking**
- **Grid integration** and stability
- **Energy storage** coordination

### ğŸ¢ Building Automation

**ğŸŒ¡ï¸ HVAC Systems**
```
Objectives:
- Minimize energy consumption
- Maintain comfort (temperature, humidity)
- Handle occupancy predictions
- Consider weather forecasts

Constraints:
- Equipment capacity limits
- Indoor air quality requirements
- Demand response signals
```

### ğŸš€ Aerospace Applications

| System | Control Variables | Constraints | Challenges |
|--------|------------------|-------------|------------|
| **ğŸ›©ï¸ Flight Control** | Control surfaces | Flight envelope | Nonlinear dynamics |
| **ğŸš€ Spacecraft** | Thrusters | Fuel limits | Orbital mechanics |
| **ğŸš UAV** | Rotor speeds | Battery life | Disturbance rejection |

---

## 9. Advantages and Disadvantages {#advantages-and-disadvantages}

### âœ… Advantages of MPC

| Advantage | Description | Impact |
|-----------|-------------|---------|
| **ğŸ¯ Optimal Control** | Minimizes cost function at each step | Better performance |
| **â›“ï¸ Constraint Handling** | Naturally incorporates limits | Safety assurance |
| **ğŸ”® Predictive Nature** | Uses future information | Proactive control |
| **ğŸ›ï¸ MIMO Capability** | Handles multiple variables naturally | System-wide optimization |
| **ğŸ”§ Flexibility** | Easy to modify objectives/constraints | Adaptable to changes |
| **ğŸ“Š Systematic Design** | Model-based approach | Principled tuning |

### âŒ Disadvantages of MPC

| Disadvantage | Description | Mitigation |
|--------------|-------------|------------|
| **ğŸ’» Computational Burden** | Requires solving optimization online | Faster algorithms, better hardware |
| **ğŸ¯ Model Dependency** | Performance depends on model quality | Robust/adaptive MPC |
| **ğŸ”§ Complex Implementation** | Requires expertise to implement | Commercial tools, education |
| **ğŸ’° High Cost** | Expensive hardware/software | Cost-benefit analysis |
| **ğŸ› ï¸ Maintenance** | Requires skilled personnel | Training, documentation |
| **ğŸ“ Parameter Tuning** | Many parameters to adjust | Systematic tuning methods |

### âš–ï¸ Trade-offs Summary

| Aspect | Benefit | Cost |
|--------|---------|------|
| **Performance** | Optimal control | High computation |
| **Safety** | Constraint handling | Complex implementation |
| **Flexibility** | Easy modifications | Expert knowledge needed |
| **Predictive** | Future optimization | Model uncertainty |

---

## ğŸ“ Summary and Key Takeaways

### ğŸ¯ When MPC Excels
- **Complex multivariable systems** with constraints
- **Applications requiring optimization** (economic, energy)
- **Systems with preview information** available
- **Safety-critical applications** with hard limits

### âš ï¸ When to Consider Alternatives
- **Simple SISO systems** â†’ Use PID
- **Very fast dynamics** â†’ Use classical control
- **Limited computational resources** â†’ Use simpler methods
- **High reliability requirements** â†’ Use robust control

### ğŸš€ Future Trends
- **ğŸ¤– Machine Learning Integration**: Data-driven MPC
- **â˜ï¸ Cloud-based MPC**: Distributed optimization
- **âš¡ Real-time Implementation**: Faster algorithms
- **ğŸ”§ Plug-and-play Solutions**: Easier deployment

### ğŸ“š Learning Path
1. **Master fundamentals**: Linear algebra, optimization
2. **Understand system modeling**: State-space, identification
3. **Start with linear MPC**: Simple examples
4. **Progress to nonlinear MPC**: Advanced applications
5. **Explore specialized topics**: Robust, stochastic, economic MPC

---

*"MPC is not just a control technique; it's a framework for systematic thinking about optimal control under constraints."*
